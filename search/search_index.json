{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Library intended for rapid prototyping in embedded devices with support of standard interfaces such as USB, UART and RS485. It supports addressing for interfaces where it makes sense and tries to be as modular and easily extensible as possible.","title":"Home"},{"location":"#home","text":"Library intended for rapid prototyping in embedded devices with support of standard interfaces such as USB, UART and RS485. It supports addressing for interfaces where it makes sense and tries to be as modular and easily extensible as possible.","title":"Home"},{"location":"For_Developers/Using_MkDocs/","text":"Install mkdocs if you haven\u2019t already, here are the instructions. For full documentation visit mkdocs.org . View Docs locally Run mkdocs serve from the root project directory, this starts up a local server to which you can connect using your browser, usually at http://localhost:8000/ . The server watches for changes and automatically refreshes the site. There is no need to use the mkdocs build command, this creates all the html files needed for deployment and we use a different method for that.","title":"Using MkDocs"},{"location":"For_Developers/Using_MkDocs/#view-docs-locally","text":"Run mkdocs serve from the root project directory, this starts up a local server to which you can connect using your browser, usually at http://localhost:8000/ . The server watches for changes and automatically refreshes the site. There is no need to use the mkdocs build command, this creates all the html files needed for deployment and we use a different method for that.","title":"View Docs locally"},{"location":"For_Developers/Design/Callbacks/","text":"a way to provide one way communication between objects through functions regardless of the arguments subject.emit(data, adress, port) -> observer1 .. -> observerN subject can be a separate class from the the object that is actually creating the event since the data can be passed into the subjects easily observers must be member functions of objects since they usually need to keep their own data and contexts - this is where the problem arises since now we can\u2019t teplate the entire object because observers may want to subscribe to multiple subjects who each can have different signatures subjects must be templates of the observer\u2019s function signature, or rather only such observers can subscribe who match the signature of the subject","title":"Callbacks"},{"location":"For_Developers/Design/General/","text":"prealokace po\u017eadavky od ka\u017ed\u00e9 vrstvy interface pot\u0159ebuje header a footer potenci\u00e1ln\u00ed security pot\u0159ebuje hlavi\u010dku i footer fragmentation nepot\u0159ebuje prealokaci porty pot\u0159ebuj\u00ed hlavi\u010dku chce to n\u011bco ve smyslu data_size objektu, kter\u00fd nese doporu\u010den\u00e9 velikosti front a back. Ka\u017ed\u00e1 vrstva definuje constantu s t\u00edmto objektem, objekt podporuje s\u010d\u00edt\u00e1n\u00ed a p\u0159ed\u00e1v\u00e1 se vy\u0161\u0161\u00edm vrstv\u00e1m","title":"prealokace"},{"location":"For_Developers/Design/General/#prealokace","text":"po\u017eadavky od ka\u017ed\u00e9 vrstvy interface pot\u0159ebuje header a footer potenci\u00e1ln\u00ed security pot\u0159ebuje hlavi\u010dku i footer fragmentation nepot\u0159ebuje prealokaci porty pot\u0159ebuj\u00ed hlavi\u010dku chce to n\u011bco ve smyslu data_size objektu, kter\u00fd nese doporu\u010den\u00e9 velikosti front a back. Ka\u017ed\u00e1 vrstva definuje constantu s t\u00edmto objektem, objekt podporuje s\u010d\u00edt\u00e1n\u00ed a p\u0159ed\u00e1v\u00e1 se vy\u0161\u0161\u00edm vrstv\u00e1m","title":"prealokace"},{"location":"For_Developers/Design/Data/Bytes_Container/","text":"Bytes Container protocols need a byte container, which not only can reserve space in the back, but also, perhaps more importantly, at the front of the data","title":"Bytes Container"},{"location":"For_Developers/Design/Data/Bytes_Container/#bytes-container","text":"protocols need a byte container, which not only can reserve space in the back, but also, perhaps more importantly, at the front of the data","title":"Bytes Container"},{"location":"For_Developers/Design/Layers/Fragmentation/","text":"Fragmentation Initial thoughts We can build the fragment fragmentation logic on top of the interface, this logic should have its own internal buffer for fragments received from events, because once the event fires, the fragment is forgotten on the interface side to avoid the need for direct access to the interface\u2019s RX queue. fragmentation handler needs to implement basic congestion and flow control. each handler manages only one interface, each interface can be connected to multiple different interfaces with different addresses, so it would be beneficial to broadcast the state information to share it with everybody, but in terms of total overhead this may not be the best solution (since we are sending data that aims to prevent congestion\u2026) in order for this to be useful, the information needs to be up-to-date, so perhaps the most logical solution would be to embed it into the data itself. Perhaps a single additional byte in the fragmentation header might be sufficient to convey enough information about the receiver\u2019s state. handler should store the following information about peers - current holdoff times and capacity estimates the status value should reflect the receiver\u2019s available capacity either in absolute terms (which I do not find appealing) or using increase/decrease signaling - there will be other factors that collectively influence the rate of transmition. Reason why I think absolute would not work is because these systems are not necessarily linear. terminologie hrani\u010dn\u00ed fragment = prvn\u00ed nebo posledn\u00ed fragment transferru hlavn\u00ed fragment = fragment transferu, kter\u00fd nen\u00ed hrani\u010dn\u00ed \u0159\u00eddic\u00ed fragment = ACK, REQ, atd. Nenese data, je to jen hlavi\u010dka m\u011b\u0159en\u00ed RTT prvn\u00ed (posledn\u00ed) fragment p\u0159ed\u00e1n interface od interface p\u0159ijde konfirmace odesl\u00e1n\u00ed (tu interface generuje ve chv\u00edli odesl\u00e1n\u00ed prvn\u00edho byte) od prot\u011bj\u0161ku p\u0159ijde ACK fragment (nebo v p\u0159\u00edpad\u011b posledn\u00edho potenci\u00e1ln\u011b je\u0161t\u011b REQ) - ACK i REQ jsou mal\u00e9 prioritn\u00ed fragmenty, kter\u00e9 by m\u011bly obch\u00e1zet omezen\u00ed na rate, proto\u017ee by nem\u011bly v\u00fdznamn\u011b p\u0159isp\u00edvat k provozu \u0159\u00edzen\u00ed provozu po ka\u017ed\u00e9m kroku se zm\u011bn\u00ed stav transferu aby reflektoval akci. T\u00edmto se p\u0159id\u00e1v\u00e1 omezuj\u00edc\u00ed podm\u00ednka na transfer - \u017e\u00e1dn\u00fd transfer nesm\u00ed m\u00edt v\u00edce fragment\u016f \u201cve vzduchu\u201d u hrani\u010dn\u00edch fragment\u016f se \u010dek\u00e1 na odpov\u011b\u010f, odes\u00edl\u00e1n\u00ed hlavn\u00edch je \u0159\u00edzeno peer.tx_rate a (?) potenci\u00e1ln\u00edmi STATUS fragmenty. Hlavn\u00ed fragmenty nejsou jednotliv\u011b potvrzov\u00e1ny a v\u0161e je ji\u0161t\u011bno timouty. pokud se od konfirmace odesl\u00e1n\u00ed hrani\u010dn\u00edho fragmentu p\u0159ekro\u010d\u00ed maxim\u00e1ln\u00ed mez RTT, mus\u00ed se zahodit aktu\u00e1ln\u00ed m\u011b\u0159en\u00ed RTT a prov\u00e9st retransmit naposled odeslan\u00e9ho fragmentu. pokud v\u00edc t\u011bchto pokus\u016f sel\u017ee a je p\u0159ekro\u010den inactivity timeout, cel\u00fd transfer se zahazuje, stav peer n\u011bco ve smyslu (unreachable += 1) (TODO) kroky odesl\u00e1n\u00ed transferu transmit_transfer za\u0159adila transfer do fronty, jeho stav je NEW, current = 0 stav NEW nebo NEXT nebo RETRY -> ode\u0161li current fragment, stav WAITING - inkrementuj current pokud NEW nebo NEXT stav WAITING - p\u0159i\u0161la konfirmace odesl\u00e1n\u00ed, nastav stav na SENT a za\u010dni m\u011b\u0159it \u010das - konfirmace selhala (interface odm\u00edtnul fragment), cel\u00fd transfer se zahazuje stav SENT - current je hrani\u010dn\u00ed nebo retransmit_count > 0 - p\u0159i\u0161el ACK fragment, ulo\u017e zm\u011b\u0159en\u00fd rtt a nastav stav na NEXT nebo DONE, kde generujeme ack pro odes\u00edlatele a zahazujeme transfer - p\u0159i\u0161el REQ fragment, posledn\u00ed je v tom p\u0159\u00edpad\u011b v po\u0159\u00e1dku a chyb\u00ed n\u011bkter\u00fd z hlavn\u00edch, nastaven stav RETRY a current na po\u017eadovan\u00fd fragment, retransmit_count++ - timeout p\u0159ijet\u00ed ACK nebo REQ, nastav stav na RETRY (zde se m\u016f\u017ee st\u00e1t, \u017ee m\u00e1me timeout moc striktn\u00ed a ACK p\u0159ijde o n\u011bco pozd\u011bji, v takov\u00e9m p\u0159\u00edpad\u011b mus\u00edme prudce relaxovat tento timeout) - je hlavn\u00ed a uplynulo dostatek \u010dasu od odesl\u00e1n\u00ed, stav NEXT kroky p\u0159ij\u00edman\u00ed transferu p\u0159ijat prvn\u00ed fragment (bude v\u017edy prvn\u00ed v po\u0159ad\u00ed, jeliko\u017e odes\u00edlatel \u010dek\u00e1 na ACK od n\u00e1s), vytvo\u0159\u00edme nov\u00fd transfer a ode\u0161leme ACK, stav NEXT jak\u00fdkoliv dal\u0161\u00ed fragment je za\u0159azen, stav NEXT, pro posledn\u00ed fragment odesl\u00e1no ACK a stav DONE, generov\u00e1n receive_event a zahozena datov\u00e1 \u010d\u00e1st stav NEXT dlouho bez aktivity, stav DONE a expirace drop period, zahozen cel\u00fd transfer (dr\u017e\u00edme pro p\u0159\u00edpad ztr\u00e1ty posledn\u00edho) transmit priority ordering the previous implementation suffered from a load balancing problem, where it treated transfers completely independently. We need a way to order currently outgoing transfers withing the fragmentation handler in terms of \u201ctransmit priority\u201d. This should be a single metric that gives priority to certain transfers while pushing back others to prevent interface overload. Metrics that should play a role 1. how close is this transfer to completion - we need to prioritize transfers that are almost finished and hold back transfers that haven\u2019t gone out yet - the handler should attempt to minimize the number of transfers in progress (states NEXT, RETRY, WAITING and SENT) 2. transfers that fit into a single fragment - these carry little overhead - just one transmit and one ACK if everything goes smoothly - it is also likely that small transfers carry timely data as opposed by the long ones 3. time since the last transmit - we need a push for transfers that are otherwise low priority (ie. long ones near the beginning)","title":"Fragmentation"},{"location":"For_Developers/Design/Layers/Fragmentation/#fragmentation","text":"","title":"Fragmentation"},{"location":"For_Developers/Design/Layers/Fragmentation/#initial-thoughts","text":"We can build the fragment fragmentation logic on top of the interface, this logic should have its own internal buffer for fragments received from events, because once the event fires, the fragment is forgotten on the interface side to avoid the need for direct access to the interface\u2019s RX queue. fragmentation handler needs to implement basic congestion and flow control. each handler manages only one interface, each interface can be connected to multiple different interfaces with different addresses, so it would be beneficial to broadcast the state information to share it with everybody, but in terms of total overhead this may not be the best solution (since we are sending data that aims to prevent congestion\u2026) in order for this to be useful, the information needs to be up-to-date, so perhaps the most logical solution would be to embed it into the data itself. Perhaps a single additional byte in the fragmentation header might be sufficient to convey enough information about the receiver\u2019s state. handler should store the following information about peers - current holdoff times and capacity estimates the status value should reflect the receiver\u2019s available capacity either in absolute terms (which I do not find appealing) or using increase/decrease signaling - there will be other factors that collectively influence the rate of transmition. Reason why I think absolute would not work is because these systems are not necessarily linear. terminologie hrani\u010dn\u00ed fragment = prvn\u00ed nebo posledn\u00ed fragment transferru hlavn\u00ed fragment = fragment transferu, kter\u00fd nen\u00ed hrani\u010dn\u00ed \u0159\u00eddic\u00ed fragment = ACK, REQ, atd. Nenese data, je to jen hlavi\u010dka","title":"Initial thoughts"},{"location":"For_Developers/Design/Layers/Fragmentation/#mereni-rtt","text":"prvn\u00ed (posledn\u00ed) fragment p\u0159ed\u00e1n interface od interface p\u0159ijde konfirmace odesl\u00e1n\u00ed (tu interface generuje ve chv\u00edli odesl\u00e1n\u00ed prvn\u00edho byte) od prot\u011bj\u0161ku p\u0159ijde ACK fragment (nebo v p\u0159\u00edpad\u011b posledn\u00edho potenci\u00e1ln\u011b je\u0161t\u011b REQ) - ACK i REQ jsou mal\u00e9 prioritn\u00ed fragmenty, kter\u00e9 by m\u011bly obch\u00e1zet omezen\u00ed na rate, proto\u017ee by nem\u011bly v\u00fdznamn\u011b p\u0159isp\u00edvat k provozu","title":"m\u011b\u0159en\u00ed RTT"},{"location":"For_Developers/Design/Layers/Fragmentation/#rizeni-provozu","text":"po ka\u017ed\u00e9m kroku se zm\u011bn\u00ed stav transferu aby reflektoval akci. T\u00edmto se p\u0159id\u00e1v\u00e1 omezuj\u00edc\u00ed podm\u00ednka na transfer - \u017e\u00e1dn\u00fd transfer nesm\u00ed m\u00edt v\u00edce fragment\u016f \u201cve vzduchu\u201d u hrani\u010dn\u00edch fragment\u016f se \u010dek\u00e1 na odpov\u011b\u010f, odes\u00edl\u00e1n\u00ed hlavn\u00edch je \u0159\u00edzeno peer.tx_rate a (?) potenci\u00e1ln\u00edmi STATUS fragmenty. Hlavn\u00ed fragmenty nejsou jednotliv\u011b potvrzov\u00e1ny a v\u0161e je ji\u0161t\u011bno timouty. pokud se od konfirmace odesl\u00e1n\u00ed hrani\u010dn\u00edho fragmentu p\u0159ekro\u010d\u00ed maxim\u00e1ln\u00ed mez RTT, mus\u00ed se zahodit aktu\u00e1ln\u00ed m\u011b\u0159en\u00ed RTT a prov\u00e9st retransmit naposled odeslan\u00e9ho fragmentu. pokud v\u00edc t\u011bchto pokus\u016f sel\u017ee a je p\u0159ekro\u010den inactivity timeout, cel\u00fd transfer se zahazuje, stav peer n\u011bco ve smyslu (unreachable += 1) (TODO)","title":"\u0159\u00edzen\u00ed provozu"},{"location":"For_Developers/Design/Layers/Fragmentation/#kroky-odeslani-transferu","text":"transmit_transfer za\u0159adila transfer do fronty, jeho stav je NEW, current = 0 stav NEW nebo NEXT nebo RETRY -> ode\u0161li current fragment, stav WAITING - inkrementuj current pokud NEW nebo NEXT stav WAITING - p\u0159i\u0161la konfirmace odesl\u00e1n\u00ed, nastav stav na SENT a za\u010dni m\u011b\u0159it \u010das - konfirmace selhala (interface odm\u00edtnul fragment), cel\u00fd transfer se zahazuje stav SENT - current je hrani\u010dn\u00ed nebo retransmit_count > 0 - p\u0159i\u0161el ACK fragment, ulo\u017e zm\u011b\u0159en\u00fd rtt a nastav stav na NEXT nebo DONE, kde generujeme ack pro odes\u00edlatele a zahazujeme transfer - p\u0159i\u0161el REQ fragment, posledn\u00ed je v tom p\u0159\u00edpad\u011b v po\u0159\u00e1dku a chyb\u00ed n\u011bkter\u00fd z hlavn\u00edch, nastaven stav RETRY a current na po\u017eadovan\u00fd fragment, retransmit_count++ - timeout p\u0159ijet\u00ed ACK nebo REQ, nastav stav na RETRY (zde se m\u016f\u017ee st\u00e1t, \u017ee m\u00e1me timeout moc striktn\u00ed a ACK p\u0159ijde o n\u011bco pozd\u011bji, v takov\u00e9m p\u0159\u00edpad\u011b mus\u00edme prudce relaxovat tento timeout) - je hlavn\u00ed a uplynulo dostatek \u010dasu od odesl\u00e1n\u00ed, stav NEXT","title":"kroky odesl\u00e1n\u00ed transferu"},{"location":"For_Developers/Design/Layers/Fragmentation/#kroky-prijimani-transferu","text":"p\u0159ijat prvn\u00ed fragment (bude v\u017edy prvn\u00ed v po\u0159ad\u00ed, jeliko\u017e odes\u00edlatel \u010dek\u00e1 na ACK od n\u00e1s), vytvo\u0159\u00edme nov\u00fd transfer a ode\u0161leme ACK, stav NEXT jak\u00fdkoliv dal\u0161\u00ed fragment je za\u0159azen, stav NEXT, pro posledn\u00ed fragment odesl\u00e1no ACK a stav DONE, generov\u00e1n receive_event a zahozena datov\u00e1 \u010d\u00e1st stav NEXT dlouho bez aktivity, stav DONE a expirace drop period, zahozen cel\u00fd transfer (dr\u017e\u00edme pro p\u0159\u00edpad ztr\u00e1ty posledn\u00edho)","title":"kroky p\u0159ij\u00edman\u00ed transferu"},{"location":"For_Developers/Design/Layers/Fragmentation/#transmit-priority-ordering","text":"the previous implementation suffered from a load balancing problem, where it treated transfers completely independently. We need a way to order currently outgoing transfers withing the fragmentation handler in terms of \u201ctransmit priority\u201d. This should be a single metric that gives priority to certain transfers while pushing back others to prevent interface overload. Metrics that should play a role 1. how close is this transfer to completion - we need to prioritize transfers that are almost finished and hold back transfers that haven\u2019t gone out yet - the handler should attempt to minimize the number of transfers in progress (states NEXT, RETRY, WAITING and SENT) 2. transfers that fit into a single fragment - these carry little overhead - just one transmit and one ACK if everything goes smoothly - it is also likely that small transfers carry timely data as opposed by the long ones 3. time since the last transmit - we need a push for transfers that are otherwise low priority (ie. long ones near the beginning)","title":"transmit priority ordering"},{"location":"For_Developers/Design/Layers/Interface/","text":"Interface abstracts away the physical interface, for that it needs to handle - encoding, error detection and correction interfaces are inherently interrupt driven, we need to either ensure that callbacks don\u2019t take a long time or we resort to buffering, which seems like the safest and most versatile bet. But now we need to determine when the actual processing takes place. it seems that the right balance would be: decode, check, correct and determine whether the fragment belongs to us within the interrupt routine - that way only the relevant stuff gets put into the processing queue. in terms of structure it would be nice for the interface to only handle the the bits and not have to deal with the more abstract things, like addressing -> let\u2019s introduce another component (address class) that deals with that in order to maintain modularity. USB - one interrupt callback for receive, fragments are already pieced together - somewhat error checked - 64B fragment size limit UART - need to receive byte-by-byte in an interrupt (we could make it more efficient if we could constraint the fragment size to something like 8B multiples so that we benefit from the hardware) - don\u2019t know the size in advance, it should be constrained though it would be nice to somehow ignore fragments that are not meant for us, which can be done if the address class exposes how long the address should be and then vets tha fragment. But we cannot necessarily stop listening as soon as we figure this out, because we need to catch the end of the fragment + it may be useful to have a callback with fragments that were not meant to us, but someone may be interested for debugging purposes for example. so interface must already be concerned with addresses as well as with all the lower layer stuff. However it should not be handling fragment fragmentation, I\u2019d leave that to the thing that processes the RX queue. which leads us to what the interface class should expose - an RX event - a bad RX event - a TX complete event interface has an RX and a TX queue, it will throw an exception? when the TX fragment is over the maximum length. Events are fired from the main interface task, not from the interrupts, because event callbacks could take a long time to return. Queues isolate the interrupts from the main task. We can build the fragment fragmentation logic on top of the interface, this logic should have its own internal buffer for fragments received from events, because once the event firess, the fragment is forgotten on the interface side to avoid the need for direct access to the interface\u2019s RX queue. the TX queue should be size limited and an interface should be exposed for checking whether we can push to the queue without being blocked by the function call because the queue is too large. so it should also expose - write(fragment[, callback?]) a potentially blocking call - writable() or something similar Let\u2019s think again\u2026 Some interfaces are, as we said, easier to handle, like USB. Can these simple ones be a subset of the harder ones, like UART? For something like a uart it may be best to have some contiguous static buffer that we use as a ring buffer - here the isr is really simple, it just puts each byte it receives into the buffer and increments an index and handles the index wrap. It may be best to introduce a start sequence into the fragments, something like 0x5555 or whatever, which we use to lookup the start of the fragment in this large array sort of efficiently. How to handle the wrap? estimating the interface load 100% load will occur when the interface spends all of its time sending/receiving bytes for receive we can observe the ring buffer - every time we enter the do_receive function we can look at the amount of bytes the buffer accumulated since the last call of the function for transmit we can simply count bytes we are about to transmit how do we express this load? - something per second is an extremely slowly updating metric - what about /100ms?, /10ms slots? - rolling average should be quite representative - raw bytes received/transmitted should definitely be available - perhaps a good start, you can figure out a lot from this - lets say 1MB/s for a year is 1M 365 24 3600 = 31536 10^9 = 3.1536 10^13, uint32 is ~4.29 10^9, uint64 is ~1,84e19 - that should do it","title":"Interface"},{"location":"For_Developers/Design/Layers/Interface/#interface","text":"abstracts away the physical interface, for that it needs to handle - encoding, error detection and correction interfaces are inherently interrupt driven, we need to either ensure that callbacks don\u2019t take a long time or we resort to buffering, which seems like the safest and most versatile bet. But now we need to determine when the actual processing takes place. it seems that the right balance would be: decode, check, correct and determine whether the fragment belongs to us within the interrupt routine - that way only the relevant stuff gets put into the processing queue. in terms of structure it would be nice for the interface to only handle the the bits and not have to deal with the more abstract things, like addressing -> let\u2019s introduce another component (address class) that deals with that in order to maintain modularity. USB - one interrupt callback for receive, fragments are already pieced together - somewhat error checked - 64B fragment size limit UART - need to receive byte-by-byte in an interrupt (we could make it more efficient if we could constraint the fragment size to something like 8B multiples so that we benefit from the hardware) - don\u2019t know the size in advance, it should be constrained though it would be nice to somehow ignore fragments that are not meant for us, which can be done if the address class exposes how long the address should be and then vets tha fragment. But we cannot necessarily stop listening as soon as we figure this out, because we need to catch the end of the fragment + it may be useful to have a callback with fragments that were not meant to us, but someone may be interested for debugging purposes for example. so interface must already be concerned with addresses as well as with all the lower layer stuff. However it should not be handling fragment fragmentation, I\u2019d leave that to the thing that processes the RX queue. which leads us to what the interface class should expose - an RX event - a bad RX event - a TX complete event interface has an RX and a TX queue, it will throw an exception? when the TX fragment is over the maximum length. Events are fired from the main interface task, not from the interrupts, because event callbacks could take a long time to return. Queues isolate the interrupts from the main task. We can build the fragment fragmentation logic on top of the interface, this logic should have its own internal buffer for fragments received from events, because once the event firess, the fragment is forgotten on the interface side to avoid the need for direct access to the interface\u2019s RX queue. the TX queue should be size limited and an interface should be exposed for checking whether we can push to the queue without being blocked by the function call because the queue is too large. so it should also expose - write(fragment[, callback?]) a potentially blocking call - writable() or something similar Let\u2019s think again\u2026 Some interfaces are, as we said, easier to handle, like USB. Can these simple ones be a subset of the harder ones, like UART? For something like a uart it may be best to have some contiguous static buffer that we use as a ring buffer - here the isr is really simple, it just puts each byte it receives into the buffer and increments an index and handles the index wrap. It may be best to introduce a start sequence into the fragments, something like 0x5555 or whatever, which we use to lookup the start of the fragment in this large array sort of efficiently. How to handle the wrap?","title":"Interface"},{"location":"For_Developers/Design/Layers/Interface/#estimating-the-interface-load","text":"100% load will occur when the interface spends all of its time sending/receiving bytes for receive we can observe the ring buffer - every time we enter the do_receive function we can look at the amount of bytes the buffer accumulated since the last call of the function for transmit we can simply count bytes we are about to transmit how do we express this load? - something per second is an extremely slowly updating metric - what about /100ms?, /10ms slots? - rolling average should be quite representative - raw bytes received/transmitted should definitely be available - perhaps a good start, you can figure out a lot from this - lets say 1MB/s for a year is 1M 365 24 3600 = 31536 10^9 = 3.1536 10^13, uint32 is ~4.29 10^9, uint64 is ~1,84e19 - that should do it","title":"estimating the interface load"},{"location":"For_Developers/Design/Layers/Ports/","text":"Ports Unlike with TCP or UDP protocols, where ports are associated with one interface, in libprotoserial we handle ports more like service endpoints that can be device-wide. Ports are managed by the ports_handler class, which serves as node through which data of all registered interfaces and services flows.","title":"Ports"},{"location":"For_Developers/Design/Layers/Ports/#ports","text":"Unlike with TCP or UDP protocols, where ports are associated with one interface, in libprotoserial we handle ports more like service endpoints that can be device-wide. Ports are managed by the ports_handler class, which serves as node through which data of all registered interfaces and services flows.","title":"Ports"},{"location":"For_Developers/Design/Services/Command/","text":"Command Command service occupies one port of the port_handler. It is meant for short lived commands, primarily used during debugging and validation testing. Because of this it prioritizes ease of implementing commands above everything else. command_service m\u011bl by v kombinaci s podporou port\u016f \u0159e\u0161it v\u011bt\u0161inu probl\u00e9m\u016f s b\u00fdval\u00fdm TestInterface p\u0159\u00edkazy nejsou jedin\u00e1 forma komunikace se za\u0159\u00edzen\u00edm, jeliko\u017e obsazuj\u00ed pouze jeden port ka\u017ed\u00fd p\u0159\u00edkaz je specializace command_base t\u0159\u00eddy, tak\u017ee je mnohem jednodu\u0161\u0161\u00ed dr\u017eet persistent stav p\u0159\u00edkazy si st\u00e1le vyb\u00edraj\u00ed kdy se ukon\u010d\u00ed podle n\u00e1vratov\u00e9 hodnoty { DONE, CONTINUE, ERR_ARGS, ERR_RUNTIME } funkce run tady je pr\u00e1v\u011b dal\u0161\u00ed mo\u017en\u00e9 zlep\u0161en\u00ed, kter\u00e9 aktu\u00e1ln\u011b nen\u00ed implementov\u00e1no - spu\u0161t\u011bn\u00ed p\u0159\u00edkazu 1. odesl\u00e1n\u00ed json stringu ve form\u00e1tu CBOR na port command_service 2. command_service kontroluje form\u00e1t, hled\u00e1 instanci podle n\u00e1zvu p\u0159\u00edkazu 3. odpov\u00edd\u00e1 ACK odes\u00edlateli, spou\u0161t\u00ed p\u0159\u00edkaz na n\u00e1hodn\u00e9m voln\u00e9m portu, \u010d\u00edslo portu je v ACK 4. spu\u0161t\u011bn\u00fd p\u0159\u00edkaz odes\u00edl\u00e1 odpov\u011bdi z p\u0159i\u0159azen\u00e9ho n\u00e1hodn\u00e9ho portu na po\u017eadovan\u00fd port odes\u00edlatele - p\u0159edpokl\u00e1d\u00e1 se, \u017ee odes\u00edlatel si tento port otev\u0159e p\u0159ed odesl\u00e1n\u00edm po\u017eadavku zpr\u00e1va z bodu 1. { \"cmd\": \"command name\", \"args\": [\"arg0\", 1.0, \"AwQF\"], \"port\": 42, \"id\": 512 } mo\u017en\u00e9 odpov\u011bdi z bodu 2. { \"cmd\": \"command name\", \"port\": 123, \"id\": 512 } { \"cmd\": \"command name\", \"error\": \"args format\" } Command arguments Command result Calling commands command queries should be generated by instances of the command_client (also a service running on some other device for example) this makes sense, commands should behave in this client","title":"Command"},{"location":"For_Developers/Design/Services/Command/#command","text":"Command service occupies one port of the port_handler. It is meant for short lived commands, primarily used during debugging and validation testing. Because of this it prioritizes ease of implementing commands above everything else.","title":"Command"},{"location":"For_Developers/Design/Services/Command/#command_service","text":"m\u011bl by v kombinaci s podporou port\u016f \u0159e\u0161it v\u011bt\u0161inu probl\u00e9m\u016f s b\u00fdval\u00fdm TestInterface p\u0159\u00edkazy nejsou jedin\u00e1 forma komunikace se za\u0159\u00edzen\u00edm, jeliko\u017e obsazuj\u00ed pouze jeden port ka\u017ed\u00fd p\u0159\u00edkaz je specializace command_base t\u0159\u00eddy, tak\u017ee je mnohem jednodu\u0161\u0161\u00ed dr\u017eet persistent stav p\u0159\u00edkazy si st\u00e1le vyb\u00edraj\u00ed kdy se ukon\u010d\u00ed podle n\u00e1vratov\u00e9 hodnoty { DONE, CONTINUE, ERR_ARGS, ERR_RUNTIME } funkce run tady je pr\u00e1v\u011b dal\u0161\u00ed mo\u017en\u00e9 zlep\u0161en\u00ed, kter\u00e9 aktu\u00e1ln\u011b nen\u00ed implementov\u00e1no - spu\u0161t\u011bn\u00ed p\u0159\u00edkazu 1. odesl\u00e1n\u00ed json stringu ve form\u00e1tu CBOR na port command_service 2. command_service kontroluje form\u00e1t, hled\u00e1 instanci podle n\u00e1zvu p\u0159\u00edkazu 3. odpov\u00edd\u00e1 ACK odes\u00edlateli, spou\u0161t\u00ed p\u0159\u00edkaz na n\u00e1hodn\u00e9m voln\u00e9m portu, \u010d\u00edslo portu je v ACK 4. spu\u0161t\u011bn\u00fd p\u0159\u00edkaz odes\u00edl\u00e1 odpov\u011bdi z p\u0159i\u0159azen\u00e9ho n\u00e1hodn\u00e9ho portu na po\u017eadovan\u00fd port odes\u00edlatele - p\u0159edpokl\u00e1d\u00e1 se, \u017ee odes\u00edlatel si tento port otev\u0159e p\u0159ed odesl\u00e1n\u00edm po\u017eadavku zpr\u00e1va z bodu 1. { \"cmd\": \"command name\", \"args\": [\"arg0\", 1.0, \"AwQF\"], \"port\": 42, \"id\": 512 } mo\u017en\u00e9 odpov\u011bdi z bodu 2. { \"cmd\": \"command name\", \"port\": 123, \"id\": 512 } { \"cmd\": \"command name\", \"error\": \"args format\" }","title":"command_service"},{"location":"For_Developers/Design/Services/Command/#command-arguments","text":"","title":"Command arguments"},{"location":"For_Developers/Design/Services/Command/#command-result","text":"","title":"Command result"},{"location":"For_Developers/Design/Services/Command/#calling-commands","text":"command queries should be generated by instances of the command_client (also a service running on some other device for example) this makes sense, commands should behave in this client","title":"Calling commands"}]}